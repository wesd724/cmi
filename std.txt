암호화폐(코인) 모의 투자 사이트
소개: 코인 라이더는 가상화폐 투자의 세계를 탐험할 수 있는 모의 투자 플랫폼입니다.
실제 시장 데이터를 바탕으로 다양한 암호화폐에 투자하고 수익을 내는 투자 경험을 제공합니다.
직관적인 UI와 실시간 차트, 뉴스 피드를 통해 투자 정보를 쉽게 확인할 수 있습니다.
또한 커뮤니티 기능을 통해 다른 투자자들과 의견을 나누고 전략을 공유할 수 있습니다.
위험 없이 가상화폐 투자의 재미를 느껴보세요

24시간 매수매도
소수점 주식 구매 가능
상한가, 하한가 x
실제 시세 영향 x

넣을 기능:
투자 정보(개인 구매 내역, 자산관리 등) (처리)
코인 차트 그래프(프론트) (처리)
매수/매도 주문 (처리)
주문 처리 (단순 대소비교 -> 호가창) (처리)
주문 체결 알림 (처리)
각 코인별 댓글 기능 (처리)
실시간 랭킹(redis[]) (먼저 mysql로 구현 -> redis?)
인증 게시판(s3)[]
코인 추천 ai(svm(머신러닝)으로 다음날 가격 예측, 플라스크 사용) (처리)
(처리 => 완벽한 처리가 아니다. 버그 무조건 존재한다.)

코인별 뉴스(네이버 뉴스 API)(프론트)[]
최근 n일동안 구매한 코인 목록[]

새로 시도해보는것:
리액트와 스프링부트에 sse 통신
redis 사용?
s3 사용?

업비트 api로 실시간 코인 시세를 가져온다
이때 현재가는 웹소켓으로
차트 그래프를 나타내는 캔들은 rest인데 기능추가 고민중
(분, 일 단위로 보여주는 건 했는데, 실시간이나 추가적인거 고민중)
시세 체결과 호가는 기능추가 고민해봐야함(웹소켓, rest 둘다 가능)

프론트 취약점:
url로 직접 접근시 localstorage 무시(해결중)
콘솔로 localstorage 조작(스프링 시큐리티 적용 고민중)

1. 클라이언트에서 바로 웹소켓을 호출할 것
-> 파이썬(flask)으로 웹소켓을 통해 실시간 시세를 가져온 뒤에
클라이언트에서 sse로 받는 것은 네트워크를 타기때문에 비용이 든다.

2. main 창에서 구매할 코인을 선택하면, 구매창으로 넘어가게 만듬
-> 이때 선택한 코인을 구매창에서 또다시 웹소켓으로 실시간 가격을 보여주는 게 맞는 거 같음

3. 여기서 보유자산 테이블에는 KRW(한국 돈) 외에 다양한 코인들이 들어간다.
->그런데 사실상 KRW에는 보유수량,매수평균가 이런 컬럼이 필요없고, 코인에는 총매수,총평가 이런 컬럼은 필요없다.
-> 그럼 현금자산, 코인자산 두개의 테이블로 분리하는게 나아보임

4. 고민1. 내가 코인을 주문(매수/매도) 했을 때, 코인 실시간 시세에 따라서 자동으로 주문이 처리가 되어야함
-> 프론트에서 작업하는 게 아니라, 서버가 처리해줘야함
-> 서버에서 웹소켓을 사용하여 서버에서 실시간으로 처리(실시간 가격을 미체결된 거래기록 테이블과 비교)하면 과부하 날 거 같음
-> 스케줄러를 사용하는 게 나음 -> 대용량 처리가 아니므로 스프링 배치를 사용할 필요가 없음(굳이)
-> 처리 순서: 특정 주기마다 현재 시세 가져옴 -> 시세와 미체결된 거래기록 비교 -> 체결 처리 -> 각 체결된 유저의 코인자산 db에 반영

5. 고민2. 실시간 코인 가격에 따라, 유저들의 자산(현금, 코인 모두)이 변동되는데 db에 반영을 어떻게 해야 할까?
 -> 아니다. 시세에 따라 db에 자산이 바뀔 필요가 없다. 주문이 체결될때에만 db에 반영 하면 된다. 간단한 문제다.

6. 고민3. 알림 서비스. 주문이 체결된 것을 클라이언트가 알아야 한다.
-> 알림은 나중에 구현하더라도, 체결된 주문 이후 유저들의 자산 변동을 반영해야함.
-> 클라이언트에서 거래기록을 통해 알림 받아야 하는데, 폴링으로 할지, sse로 할지 고민된다.
-> sse로 결정, 폴링은 지속적으로 요청을 계속 보내야해서 서버에 부담이 큼(리소스 낭비)
-> sse를 '클라이언트' 당 연결이 아니라, '유저' 당 연결을 하도록 구현중
-> 서로 다른 컴퓨터(브라우저)에서 같은 '유저'로 접근하면, 같은 sse 객체를 받는 게 아니라 다른 객체를 받는다.
-> 즉, '유저' 별로 하나의 sse 객체를 유지 하는 게 아니라,
-> '같은 유저' 라도 클라이언트가 다르면(다른 컴퓨터) 새로운 sse 객체를 그 수만큼 만들어야 한다.
-> 새로 체결된 내용을 유저가 접속하지 않았을 때에도 잃어버리면 안되니까 저장해야됨
-> 유저가 접속중일 때에는 실시간 체결 내용을 바로 전달하면 되나? -> 그럼 이 체결내용은 따로 저장할 필요가 없나?

6-1. 거래 기록 테이블에서 체결시간까지 완료된(가장 최근에 체결이 완료된) 거래들을 알림 테이블에 insert해야 한다.
-> 체결 완료된 거래들을 모두 insert 해줘야 한다
-> 여러개의 단건 insert로 하면 db 속도 저하 & 부하 발생
-> bulk insert로 처리해야함.
-> jpa로 bulk insert를 처리하려면(batch size를 이용한), 테이블 id 생성 전략이 IDENTITY(기본 키 생성을 데이터베이스에 위임,  auto-increment로 PK 값을 자동으로 증분)면 안된다.
-> 내 mysql의 모든 테이블 생성 전략이 IDENTITY이므로 bulk 연산이 안된다.
-> 전략을 바꾸면 되긴 하는데... 단지 벌크 연산만을 위해서 테이블 구조를 바꿔야 하나..
-> MySQL은 sequence 전략이 없고, table 전략을 쓰기에는 이 테이블도 관리해야 한다는 점이 부담
-> JdbcTemplate으로 bulk연산(batchupdate) 처리

6-2. 유저별 알림을 전송(조회)할 때, 알림 테이블에 있는(trade_history_id)를 통하여 다시 연관 컬럼(주문, 가격 등)을 조회해야 한다.
-> 이 과정에서 여러 trade_history의 행들과 currency의 행들을 조회하는데, 여기서 n + 1 문제 발생.
-> queryDSL의 fetchJoin()으로 처리

7. Currency(N) : TradeHistory(1)에서, tradeHistory에서 user_id를 기준으로 조회시 해당 user와 관계되어 조회된 Currency(N)만큼
추가 쿼리 발생 -> n + 1 문제 발생 -> fetch join 으로 처리
-> CurrencyAsset 조회시에도 같은 문제 발견해서 fetch join으로 처리

8. 주문내역에서 매수, 매도 체결처리할 때(complete = true)
-> 한 행, 한 행 업그레이드하지 않고 @Modifying, @Query 이용하여 update 벌크 연산했음
-> 문제는 서버에서 10초마다 코인별로 현재 시세를 받아와서 매수, 매도 쿼리 실행함
-> 코인이 5개인 경우, 5개마다 시세가 다르다 -> 5개 각각 매수, 매도 처리 쿼리를 날림 -> 총 10개 쿼리 -> 이게 맞나?
-> QueryDSL로 처리함, 매수 쿼리 1개, 매도 쿼리 1개로 처리 
-> jpql은 다중컬럼 in을 지원 안하는 거 같다, 그리고 in절에서는 일치하는 값에서만 비교가 가능할 뿐 대소비교는 사용 못함
-> 하지만 이것도 where 절안에 코인 개수만큼 and or 이 삽입되어서 쿼리가 커지는 문제가 있다.

9. 매수/매도 주문을 하고, 주문 체결 전 상태
-> 매수 주문 시 => 주문 가능 금액 내려감, 주문 가능 코인 개수 같음
-> 매도 주문 시 => 주문 가능 금액 같음, 주문 가능 코인 개수 내려감
-> 주문할 때의 주문 가능 값은 변동되지만, 주문 체결 전에 실제 보유 금액, 보유 코인이 변하지 말아야 함
-> 보유 자산을 조회할 때에는 주문 신경안쓰고 오직 가지고 있는 자산만 보여준다
-> 주문할때에는 보유자산과 체결이 안된 주문을 가져와 합쳐서 보여준다

10. 호가창 구현 시 DB 선택
-> redis 같은 인메모리 db에 주문을 넣고 읽기, 쓰기를 할 생각이었지만
-> redis를 겉핧기식으로 급하게 배워야 함
-> 데이터 안정성 및 일관성, 트랜잭션 관리, redis 용량 한계 또는 동기화의 복잡성 등 우선 mysql로만 구현하는 게 나아보임
-> 나중에 redis의 필요성을 느끼면 그때 기술 확장할 생각

11. 호가창 기능
-> 주문을 넣을 때마다 호가창 UI를 업데이트 하기위해서 sse 사용 고려중
-> sse 사용시에 어떤식으로 설계를 해야할지 고민중이다
-> 주문 요청마다 새롭게 업데이트된 호가창을 응답 받을지?
-> 스케줄러 설정으로 n초마다 호가창을 sse로 응답 받을지?
-> 또 다른 고민해야 할 부분은, 호가창 업데이트는 주문을 코인에 대해서만 업데이트를 받으면 된다
-> 다시 말해서 A 코인 주문창에 들어가서 볼 때에는 A 코인에 대해서만 호가창 업데이트를 받으면 될뿐,
-> 다른 코인은 신경쓸 필요가 없다.
-> 근데 특정 코인에 대해서만 호가창 응답을 받게 하려면, 전역에서 SSE 연결을 할 수가 없고, 주문창에 들어갈때마다 SSE 연결을 해야한다
-> 반복적인 연결/해제이기에 리소스 낭비이고, 좋은 방법이 아니다.
-> sse는 한가지 응답만 받을 수 있는게 아니라 이벤트의 이름에 따라 여러 형태의 응답을 받을 수 있으므로
-> 이 특징을 이용해보면 될 거 같다
-> 주문을 넣으면(rest) => 주문 처리 후 => 새로운 호가창을 sse로 응답
-> 주문 넣는 것과 호가창을 기술 관점에서 분리
-> 주문 처리 과정(하나의 트랜잭션)은 다음과 같다:
-> 주문 등록 => 주문을 orderbook에 저장 => 이 호가창을 for update로 읽어드림 =>
-> 호가 처리(미체결된 호가는 업데이트, 완전 체결된 호가는 삭제 -> tradeHsitory 저장 -> 해당 유저 자산 업데이트) => 업데이트된 호가창을 sse로 알림
-> 이 과정을 두개 이상의 트랜잭션이 동시에 실행할 때 데드락이 발생했음
-> 데드락이 발생한 이유는 다음과 같다
-> T1, T2(트랜잭션 1, 2)가 동시에 주문을 넣었다고 가정하자.
-> T1: 새로운 주문을 orderbook에 저장하면 이 새로운 id에 대해 x lock 발생(예: id = 150)
-> T2: 동시에 다른 새로운 주문을 orderbook에 저장하면 이 새로운 id에 대해 x lock 발생 (예: id = 151)
-> T1: id = 150과 T2에서 새롭게 들어온 주문(id = 151)을 포함한 orderbook을 select ~ for update로 조회(x lock 잠금 요청)
-> 이 과정에서 id = 151은 이미 T2에서 x lock이 걸린 상태라 T1은 id = 151에 x lock 요청에 대해 대기
-> T2: 마찬가지로 id = 151과 T1에서 새롭게 들어온 주문(id = 150)을 포함한 orderbook을 select ~ for update로 조회(x lock 잠금 요청)
-> 이 과정에서 id = 150은 이미 T1에서 x lock이 걸린 상태라 T2은 id = 150에 x lock 요청에 대해 대기
-> T1, T2 트랜잭션(스레드)가 상대방 트랜잭션이 보유하고 있는 x-lock 잠금을 대기하고 있어, 무한대기 상태 발생
-> 데드락 감지
-> 처음 해결할때에는 주문 등록 메소드에 synchronized를 붙여 사실상 순차적으로 처리되게 했다.
-> 하지만 synchroized는 한 프로세스 내에서만 동시성 제어가 됨
-> 즉, 백엔드 서버가 2대 이상 일떄에는 synchronized가 동시성 보장을 못함
-> synchronized는 애플리케이션 레벨(JVM 수준)의 락이기 때문에 DB 레벨에서의 동시성 제어는 못한다.
-> 다른 해결 방법을 찾아봐야함
-> 데드락 자체를 없애야 한다
-> 해결 방법: insert -> select ~ for update 가 아닌, select ~ for update -> insert를 하면
-> 방금과 같은 상황일 때, T1은 트랜잭션을 계속진행하지만, T2는 T1이 끝날 때까지 select ~ for update 에서 대기로 들어감
-> 데드락 해결

12. 호가창 트랜잭션 분리 시도
-> 데드락 발생 가능성을 줄일 수 있는 방법중에, 
-> "트랜잭션의 기간을 짧고 작게 유지"하는 방법이 있다. 이유는 다음과 같다.
-> 트랜잭션이 짧을수록 자원(예: 데이터베이스 행)을 잠그는 시간이 줄어든다.
-> 이로 인해 다른 트랜잭션이 같은 자원에 접근하려 할 때 대기 시간이 줄어들거나 충돌 자체가 발생하지 않을 가능성이 높아진다.
-> 짧은 트랜잭션은 빨리 완료되므로, 다른 트랜잭션과 충돌 가능성이 줄어든다.
-> 데드락은 보통 여러 트랜잭션이 서로 다른 자원를 기다리는 상황에서 발생한다.
-> 따라서 트랜잭션 시간이 짧으면, 이런 '기다리는' 상황이 발생할 확률이 줄어든다.
-> 이게 이유이다. 따라서 적용해 보려고 한다.
-> 호가창 처리는 원래 여러개의 작업이 하나의 트랜잭션으로 묶여 처리되는데, 이 트랜잭션을 나누기로 시도해 보았다.
-> 호가창 처리(주문 처리)는 다음과 같다.
-> 주문 접수 -> 주문 처리(주문 업데이트 및 삭제, 거래내역 저장) -> 자산 업데이트 -> 알림 저장 -> sse 응답
-> 이 하나의 트랜잭션을 @Transactional(propagation = Propagation.REQUIRES_NEW)를 이용해
-> 주문 처리 부분 또는 (자산 업데이트 -> 알림 저장) 부분을 별도의 트랜잭션으로 분리 하려고 시도
-> 하지만 잘못된 결과 또는 오류가 발생함
-> 주문 처리 하는 과정에서 수많은 트랜잭션이 분리 되어 커넥션풀 부족 발생
-> REQUIRES_NEW로 트랜잭션을 분리하여 새로운 트랜잭션이 실행될 떄 새로운 DB 커넥션을 사용한다.
-> 사용가능한 커넥션 풀 사이즈가 있는데, 새로운 커넥션을 가져오는 과정에서, 기존 트랜잭션이 대기하는 상황 빌생
-> 동시에 수많은 스레드가 커넥션을 얻어 진행하는 경우, 이 각각의 스레드에서 새로운 트랜잭션을 위한 새로운 커넥션을 가져오려고 함
-> 오랜 대기로 인한 timeout 발생 (정확한 이유를 못찾음. 교착상태? 외래키 잠금으로 인한 교착상태?)
-> hikariCP를 통해 DB 커넥션풀(maximumPoolSize)을 늘려주면 해결되기는 한다.
-> 하지만 무작정 커넥션 풀 사이즈를 늘려주면 DB 부하, 병목, 리소스 제한 등 무조건 고려해야 할 것이 많다.
-> *이후, 이유를 찾아본 결과, 한 트랜잭션에서 커넥션을 2개 사용함(JPA id 기본 값 특성)
-> 이때, 나는 한 작업이 하나의 트랜잭션이 아닌, 여러개의 트랜잭션으로 분기함
-> REQUIRES_NEW 옵션으로 새로운 트랜잭션을 열어 새로운 커넥션을 획득한다.
-> 이 과정에서 커넥션 1개가 더 필요함
-> (REQUIRES_NEW을 안하고 이벤트가 AFTER_COMMIT인 상태에서는 기존 트랜잭션에 참여한다.)
-> 따라서 커넥션 풀 개수는 스레드 풀 개수보다 2개가 더 많아야 한다.
-> 커넥션 풀을 안늘리면, 커넥션 획득에서 대기가 발생하는 이유는 모든 스레드에서 최소 3개의 커넥션을 원하기 때문이다.
-> 따라서 커넥션 풀 개수가 2개만 더 많으면, 하나씩 작업을 완료하면서 모든 스레드의 작업이 완료되는 것이다.
-> 현재 주문 처리 트랜잭션 분리는 다음과 같이 했다. 괄호가 하나의 트랜잭션이다.
-> (주문 접수 -> 주문 처리(주문 업데이트 및 삭제, 거래내역 저장)) -> 이벤트 발행 -> sse 응답
-> 이벤트 수신 -> (알림 저장), (코인 자산 변경 -> 현금 자산 변경)
-> 이 주문 처리 과정, 이벤트를 이용한 처리를 메시지큐나 redis도 고민해보면 좋을 거 같다.

13. 호가창 주문 처리 과정 고민
-> 원래 구현은
-> 주문이 접수되면 -> 해당 코인에 대한 모든 활성 주문을 읽은 다음, 매수 >= 매도 인 주문을 처리 하도록 설계
-> 주문을 모두 읽는 것이 맞나?
-> 매수주문이 들어오면, 그 매수가보다 낮거나 같은 매도 주문만 읽고,
-> 매도주문이 들어오면, 그 매도가보다 높거나 같은 매수 주문만 읽어서 처리하는 게 더 좋을수도 있다
-> 이렇게 구현할 시에, 주문 처리 후 변경된 주문(업데이트된 주문 + 새로 들어온 주문)에 대한 반영을 해야한다
-> 변경된 주문만 프론트에 전달하면 될 거 같지만, 문제점이 하나 있다
-> 삭제된 주문 정보도 따로 프론트에 전달해줘서 프론트의 리스트에서 삭제해줘야 한다.
-> 그럼 따로 서버에서 삭제된 주문을 가지고 있어야 한다.
-> 복잡도 증가.
-> 그냥 마지막에 반환할때에는 모든 활성 주문을 읽는 방법이 있는데, 다시 읽는 것이기에 이러면 성능이 저하된다.
-> 이럴거면 주문 처리 할때부터 모든 활성 주문 읽는 게 더 낫다.
-> 범위조건으로 인해 락 범위가 줄어들어 동시성 제어 측면에서는 이 방법이 낫지만,
-> 주문 접수 -> ~ -> sse 응답 시간은 성능이 저하된다.

15. 회원가입 후 코인 지급 @Async 처리
-> 회원가입을 하면 코인별로 일정 수량을 지급된다.
-> 이 기능은 외부 API를 호출해 코인별 현재 가격 조회 후 코인 자산 DB에 저장
-> 이 과정을 @Async로 분리하여 비동기 처리 했음

16. sse 알림 전송을 체결시마다 안하는 이유
-> 주문이 체결될때마다 매수자, 매도자에게 알림을 전송하는 건 좋은 방법일수도 있다
-> 문제는, 그 체결된 사용자가 미접속 상태일때다.
-> 미접속 사용자는 나중에라도 알림을 못받는 것이다.
-> 물론, 못받은 알림을 체크해서 다른 주문 체결시에, 그 알림을 포함해서 보낼 수 있지만
-> 간단한 구현를 위해 주기적으로 읽지 않고, 체결된 알림을 전송하는 식으로 설계했다.

17. 현실성, 실시간성을 위해 체결시마다 sse 알림 전송
-> 10초마다 현재 접속한 유저에게 모두 알림 전송도 하고
-> 주문을 넣을 때 체결 처리 과정에서 알림 저장 이후 @Async를 이용해 비동기로 알림 전송
-> 체결된 주문의 사용자가 현재 접속 안 했을 경우를 대비하여 알림 테이블 + 10초 스케줄링 알림을 유지하는 것이다.

18. 가상 주문 생성
-> 스케줄러로 n초마다 실제 매수, 매도 1호가를 가져와 코인별로 주문을 넣는다.
-> 실제 매도 1호가는 매도 주문으로, 실제 매수 1호가는 매수 주문으로 생성했다.
-> 이게 반복되면 쌓이는 주문이 대량으로 생기기에 특정 시간마다 미체결된 가상 주문을 정리해준다.
-> 가상 유저로 정한 특정 user_id로 가상 주문을 넣고, 체결된 가상 주문은 tradeHistory로 안넘기도록 했다.

19. 외부 API 호출 실패
-> 외부 API를 호출하는 과정에서, 예외가 발생하는 경우가 있다.
-> 스케줄러나 비동기 호출에서 외부 API를 이용하는 데, 예외가 발생하면 진행이 제대로 안된다.
-> 예외가 발생하면, @Retryable을 통해 일정시간 뒤에 재시도를 하는 방식을 택하여 예외 발생을 처리했다.
