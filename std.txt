암호화폐(코인) 모의 투자 사이트
소개: 코인 라이더는 가상화폐 투자의 세계를 탐험할 수 있는 모의 투자 플랫폼입니다.
실제 시장 데이터를 바탕으로 다양한 암호화폐에 투자하고 수익을 내는 투자 경험을 제공합니다.
직관적인 UI와 실시간 차트, 뉴스 피드를 통해 투자 정보를 쉽게 확인할 수 있습니다.
또한 커뮤니티 기능을 통해 다른 투자자들과 의견을 나누고 전략을 공유할 수 있습니다.
위험 없이 가상화폐 투자의 재미를 느껴보세요

24시간 매수매도
소수점 주식 구매 가능
상한가, 하한가 x
실제 시세 영향 x

넣을 기능:
개인 정보(개인 구매 내역, 자산관리 등) (처리)
코인 차트 그래프(프론트) (처리)
매수/매도 (처리)
주문 체결 알림
각 코인별 댓글 기능
실시간 랭킹(redis[]) (먼저 mysql로 구현 -> redis)
인증 게시판(s3)[]
코인별 뉴스(네이버 뉴스 API)(프론트)[]

코인 추천 ai(svm(머신러닝)으로 다음날 가격 예측, 플라스크 사용)
최근 n일동안 구매한 코인 목록[]

새로 시도해보는것:
리액트와 스프링부트에 sse 통신
redis 사용
s3 사용

업비트 api로 실시간 코인 시세를 가져온다
이때 현재가는 웹소켓으로
차트 그래프를 나타내는 캔들은 rest인데 기능추가 고민중
(분, 일 단위로 보여주는 건 했는데, 실시간이나 추가적인거 고민중)
시세 체결과 호가는 기능추가 고민해봐야함(웹소켓, rest 둘다 가능)

프론트 취약점:
url로 직접 접근시 localstorage 무시(해결중)
콘솔로 localstorage 조작(스프링 시큐리티 적용 고민중)

1. 클라이언트에서 바로 웹소켓을 호출할 것
-> 파이썬(flask)으로 웹소켓을 통해 실시간 시세를 가져온 뒤에
클라이언트에서 sse로 받는 것은 네트워크를 타기때문에 비용이 든다.

2. main 창에서 구매할 코인을 선택하면, 구매창으로 넘어가게 만듬
-> 이때 선택한 코인을 구매창에서 또다시 웹소켓으로 실시간 가격을 보여주는 게 맞는 거 같음

3. 여기서 보유자산 테이블에는 KRW(한국 돈) 외에 다양한 코인들이 들어간다.
->그런데 사실상 KRW에는 보유수량,매수평균가 이런 컬럼이 필요없고, 코인에는 총매수,총평가 이런 컬럼은 필요없다.
-> 그럼 현금자산, 코인자산 두개의 테이블로 분리하는게 나아보임

4. 고민1. 내가 코인을 주문(매수/매도) 했을 때, 코인 실시간 시세에 따라서 자동으로 주문이 처리가 되어야함
-> 프론트에서 작업하는 게 아니라, 서버가 처리해줘야함
-> 서버에서 웹소켓을 사용하여 서버에서 실시간으로 처리(실시간 가격을 미체결된 거래기록 테이블과 비교)하면 과부하 날 거 같음
-> 스케줄러를 사용하는 게 나음 -> 대용량 처리가 아니므로 스프링 배치를 사용할 필요가 없음(굳이)
-> 처리 순서: 특정 주기마다 현재 시세 가져옴 -> 시세와 미체결된 거래기록 비교 -> 체결 처리 -> 각 체결된 유저의 코인자산 db에 반영

5. 고민2. 실시간 코인 가격에 따라, 유저들의 자산(현금, 코인 모두)이 변동되는데 db에 반영을 어떻게 해야 할까?
 -> 아니다. 시세에 따라 db에 자산이 바뀔 필요가 없다. 주문이 체결될때에만 db에 반영 하면 된다. 간단한 문제다.

6. 고민3. 알림 서비스. 주문이 체결된 것을 클라이언트가 알아야 한다.
-> 알림은 나중에 구현하더라도, 체결된 주문 이후 유저들의 자산 변동을 반영해야함.
-> 클라이언트에서 거래기록을 통해 알림 받아야 하는데, 폴링으로 할지, sse로 할지 고민된다.
-> sse로 결정, 폴링은 지속적으로 요청을 계속 보내야해서 서버에 부담이 큼(리소스 낭비)
-> sse를 '클라이언트' 당 연결이 아니라, '유저' 당 연결을 하도록 구현중
-> 새로 체결된 내용을 유저가 접속하지 않았을 때에도 잃어버리면 안되니까 저장해야됨
-> 유저가 접속중일 때에는 실시간 체결 내용을 바로 전달하면 되나? -> 그럼 이 체결내용은 따로 저장할 필요가 없나?

6-1. 거래 기록 테이블에서 체결시간까지 완료된(가장 최근에 체결이 완료된) 거래들을 알림 테이블에 insert해야 한다.
-> 체결 완료된 거래들을 모두 insert 해줘야 한다
-> 여러개의 단건 insert로 하면 db 속도 저하 & 부하 발생
-> bulk insert로 처리해야함.
-> jpa로 bulk insert를 처리하려면(batch size를 이용한), 테이블 id 생성 전략이 IDENTITY(기본 키 생성을 데이터베이스에 위임,  auto-increment로 PK 값을 자동으로 증분)면 안된다.
-> 내 mysql의 모든 테이블 생성 전략이 IDENTITY이므로 bulk 연산이 안된다.
-> 전략을 바꾸면 되긴 하는데... 단지 벌크 연산만을 위해서 테이블 구조를 바꿔야 하나..
-> MySQL은 sequence 전략이 없고, table 전략을 쓰기에는 이 테이블도 관리해야 한다는 점이 부담
-> JdbcTemplate으로 bulk연산(batchupdate) 처리

6-2. 유저별 알림을 전송(조회)할 때, 알림 테이블에 있는(currency_id, trade_history_id)를 통하여 다시 연관 컬럼(주문, 가격 등)을 조회해야 한다.
-> 이 과정에서 여러 trade_history의 행들과 currency의 행들을 조회하는데, 여기서 n + 1 문제 발생.
-> queryDSL의 fetchJoin()으로 처리

7. Currency(N) : TradeHistory(1)에서, tradeHistory에서 user_id를 기준으로 조회시 해당 user와 관계되어 조회된 Currency(N)만큼
추가 쿼리 발생 -> n + 1 문제 발생 -> fetch join 으로 처리
-> CurrencyAsset 조회시에도 같은 문제 발견해서 fetch join으로 처리

8. 주문내역에서 매수, 매도 체결처리할 때(complete = true)
-> 한 행, 한 행 업그레이드하지 않고 @Modifying, @Query 이용하여 update 벌크 연산했음
-> 문제는 서버에서 10초마다 코인별로 현재 시세를 받아와서 매수, 매도 쿼리 실행함
-> 코인이 5개인 경우, 5개마다 시세가 다르다 -> 5개 각각 매수, 매도 처리 쿼리를 날림 -> 총 10개 쿼리 -> 이게 맞나?
-> QueryDSL로 처리함, 매수 쿼리 1개, 매도 쿼리 1개로 처리 
-> jpql은 다중컬럼 in을 지원 안하는 거 같다, 그리고 in절에서는 일치하는 값에서만 비교가 가능할 뿐 대소비교는 사용 못함
-> 하지만 이것도 where 절안에 코인 개수만큼 and or 이 삽입되어서 쿼리가 커지는 문제가 있다.